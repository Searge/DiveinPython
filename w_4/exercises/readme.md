# Файл с магическими методами
В этом задании нужно было аккуратно реализовать несколько классических магических методов и пару обычных. При инициализации мы сохраняем путь, а также можем проверить существование файла, хотя это и не требовалось при тестировании. Методы `write` и `read` просто работают с файлом в системе. Хотя наличие метода для чтения не требовалось, его реализация помогает нам в работе других функций, да и вообще — какой `write` без `read`.

Метод `__str__` вряд ли вызвал у вас проблемы, остальные методы более интересны. При сложении файлов на нас ложится задача выбора имени нового файла. В условии про именование ничего не сказано, и в реальных задачах почти всегда над такими деталями приходится думать самостоятельно. В примере мы генерим имя с помощью модуля `uuid`, который позволяет создавать идентификаторы `UUID`. Файл мы сохраняем в той же директории, что и существующий, что помогает избежать проблем с правами (можно использовать `gettempdir` как в условии).

При итерации главным вопросом является сохранение номера прочитанной строки. Самым простым вариантом было бы просто вернуть итератор строк, например, с помощью метода `readlines`. Однако, в таком случае мы читаем сразу весь файл, который может быть очень большим и который весь нам может быть и не нужен. В нашем решении мы сохраняем текущую позицию в файле с помощью метода `tell` и используем `readline` для получения единственной следующей строки. По окончании чтения файла метод выбрасывает `StopIteration`, как каждый уважающий себя итератор. Можно было также использовать то, что файловый объект в Python сам по себе является итератором.

# Дескриптор с комиссией

Задача практически полностью повторяет пример из лекции, поэтому проблем с ней возникнуть было не должно. Надо только разобраться с тем, из какого объекта брать комиссию. Дескрипторы крайне редко встречаются в реальных приложениях, тем не менее, важно хотя бы на базовом уровне понимать принцип их работы.