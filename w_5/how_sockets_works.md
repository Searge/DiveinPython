# Как работают сокеты
[как наша программа с ними взаимодействует](https://www.coursera.org/learn/diving-in-python/discussions/weeks/5/threads/usa41h3BEem5KhKIZoRMNg)

***

> <font color="lightgray">Egor: </font><br />

Сокетами во время приема данных управляет ОС? Это какая-то отдельная задача от нашей программы? Наша программа использует вызов `conn.recv(1024)`. Эта отдельная задача принимает 1024 байта, накапливает их где-то и только после этого передает их нашему процессу (нашей программе)? Во время приема данных наш процесс останавливается и не использует CPU? Или это всё как-то по-другому работает?

***
<font color="lightgray">shveenkov: </font><br />
Сокетами управляет ядро ОС.

Наша программа использует вызов `conn.recv(1024)`, да, ядро ОС понимает что данных в сокете нет и "усыпляет" нашу программу. CPU при этом наша программа не использует, она просто спит. Как только данные в сокете появятся, ядро ОС "разбудит нашу программу", и вызов recv вернет нужные данные.

По-простому это нужно понимать как то так. В конкретных ОС реализация может немного отличаться.

***
> <font color="lightgray">Egor: </font><br />

А наша программа будет спать, пока ядро ОС не получит не менее 1024 байт, если процесс передачи данных ещё продолжается, например, от удаленного клиента? То есть если, например, ОС получила 512 байт и процесс получения данных не завершен, то будить она нашу программу не будет?

И аналогично это работает для потоков? Пока у ядра ОС нет для потока 1024 байт, а есть меньше или ноль, то поток спит, но работает другой поток. Но когда все 1024 байта получены, то поток просыпается и может снова получить GIL и продолжить свое выполнение, если захватит GIL? А ядро ОС при всём этом может использовать одновременно несколько CPU для одновременного скачивания, например, файлов, пока потоки спят? Или даже не CPU, а сетевую карту без обращения к CPU? Сетевая карта может одновременно получать много файлов и класть их в RAM, используя DMA?

И если есть какая-то параллельность в получении, например, файлов, которая реализована на уровне ядра ОС, то аналогичным же образом её использует и `asyncio`? Просто `asyncio` опрашивает все соединения по очереди, и если для какого-то соединения все 1024 байт получены, то наша программа начинает их обрабатывать? Правда, в случае с потоками потоки выполняется поочередно некими порциями, а в случае с `asyncio` следующий обработчик полученных данных запустится только после окончания обработки текущих полученных данных?

***
<font color="lightgray">shveenkov: </font><br />
> А наша программа будет спать, пока ядро ОС не получит не менее 1024 байт, если процесс передачи данных ещё продолжается, например, от удаленного клиента?

Нет, как только появятся данные, не обязательно 1024, ядро ОС разбудит процесс с питоном, и вызов `recv(1024)` вернет эти данные, их может быть меньше чем 1024.

> И аналогично это работает для потоков? Пока у ядра ОС нет для потока 1024 байт, а есть меньше или ноль, то поток спит, но работает другой поток.

С этой точки зрения поток он работает также как и процесс, выполнением потока занимается ядро ОС, у потока свой стек, ядро точно также его "усыпит" и "разбудит" как только данные в сокете появятся.

> Но когда все 1024 байта получены, то поток просыпается и может снова получить GIL и продолжить свое выполнение, если захватит GIL?

C GIL все так, верно, но поток не обязательно получит 1024 байта, может получить и меньше, сколько ядро вернет в системном вызове `recv` - столько и получит.

> А ядро ОС при всём этом может использовать одновременно несколько CPU для одновременного скачивания, например, файлов, пока потоки спят?

Ядро использует все ресурсы железа, все CPU, но само ядро файлы никакие не скачивает. Оно выполняет системные вызовы, такие как `recv`, `send`, и возвращает управление в `userspace`, выполняет процессы, запущенные в нем.

> Или даже не CPU, а сетевую карту без обращения к CPU? Сетевая карта может одновременно получать много файлов и класть их в RAM, используя DMA?

В такие дебри не хочется спускаться, это уже зависит от конкретной ОС и реализации работы в ней.

> И если есть какая-то параллельность в получении, например, файлов, которая реализована на уровне ядра ОС, то аналогичным же образом её использует и `asyncio`?

С `asyncio` все происходит в одном потоке, параллельности нет, все делается последовательно. Например, запускается несколько корутин, которые делают системный вызов `recv(1024)`. В таком случае управлением выполнением корутин занимается не ОС (как в случае с потоками), а _event loop_ `asyncio`.

Внутри _event loop_ будут выполнены неблокирующие операции `epoll.poll`, _event loop_ "как-бы спросит" у ядра ОС, а "какие сокеты готовы к вычитыванию данных", и ядро вернет эти сокеты. Далее из них _event loop_ прочитает в неблокирующем режиме, и вернет данные в корутины, и продолжит их выполнять.

Получается более быстрое и эффективное переключение контекста, по сравнению с потоками.

Т.е. корутины засыпают и просыпаются не под управлением ОС, прыгая из system space в user space. А async _event loop_ делает это при помощи yield, гораздо эффективнее, он сам знает какие корутины можно "будить" а какие нет.

***
<font color="lightgray">Egor: </font><br />
> Нет, как только появятся данные, не обязательно 1024, ядро ОС разбудит процесс с питоном, и вызов `recv(1024)` вернет эти данные, их может быть меньше чем 1024.

Тогда он, возможно, практически не будет засыпать или будет постоянно просыпаться, если каждый новый бит или байт его будет будить? То есть conn.recv(1024) получает эти 1024 байт не все сразу, а по частям? Или Вы имеете в виду, что просто прийти может в итоге меньше, чем 1024 байт?

> Ядро использует все ресурсы железа, все CPU, но само ядро файлы никакие не скачивает. Оно выполняет системные вызовы, такие как recv, send, и возвращает управление в userspace, выполняет процессы, запущенные в нем.

А если поток или процесс уснул и ожидает данные, то что именно в компьютере занимается получением этих данных? Например, при скачивании файлов. Если идет взаимодействие с СУБД (а не с удаленным компьютером), то, видимо, СУБД выполняет полученный запрос и когда соберет все данные, то передает их нашей программе, разбудив её для получения данных? В данном случае будет просто взаимодействие двух процессов (программ) на одном компьютере? А при скачивании файлов не очень понятно, что происходит.

> С `asyncio` все происходит в одном потоке, параллельности нет, все делается последовательно.

Это мне понятно. Но параллельность, возможно, есть на уровне, например, скачивания файлов? То есть, возможно, скачиваются одновременно несколько файлов, корутины спят в это время, а потом первой просыпается та, для которой уже получены данные?


